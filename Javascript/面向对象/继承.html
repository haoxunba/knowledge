<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    // 1. 原型链继承 缺点： 实例化时不能向超类型传参,如果超类型的值是引用类型，会造成污染
    /* function Super() {
      this.name = '原型链'
    }
    Super.prototype.sayName = function() {
      alert(this.name);
    }

    function Sub() {

    }
    Sub.prototype = new Super();
    var sub = new Sub();
    sub.sayName(); */

    // 2. 构造函数继承 虽然可以传参，但是没有继承到超类型的原型
    /* function Super(name) {
      this.name = name
    }
    Super.prototype.sayName = function() {
      alert(this.name);
    }

    function Sub(name) {
      Super.call(this, name);
    }

    var sub = new Sub('sub');
    sub.sayName();  */

    // 3. 组合继承 最常用
    /* function Super(name) {
      this.name = name
    }
    Super.prototype.sayName = function() {
      alert(this.name);
    }

    function Sub(name) {
      Super.call(this, name);
    }
    Sub.prototype = new Super();
    var sub = new Sub('sub');
    sub.sayName(); 
 */

  // 4. 原型式继承 不需要创建自定义类型
  function object(prototype) {
    var o = new Object();
    o.prototype = prototype;
    return o;
  }
  var proto =  {}
  var o1 = object(proto);
  var o2 = object(proto);

  // 5. 寄生式继承 对原型式继承的增强
  function container(proto) {
    var o = new Object(proto);
    o.add = function() {};
    return o;
  }
    
  </script>
</body>
</html>